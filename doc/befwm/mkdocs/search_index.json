{
    "docs": [
        {
            "location": "/",
            "text": "befwm documentation\n\n\n\n\nUser guide\n\n\nGenerating random networks\n\n\nNiche model\n\n\n\n\n\n\nOverview of the simulation\n\n\nCreate model parameters\n\n\nSimulation\n\n\n\n\n\n\nMeasures on output\n\n\nPopulation variability\n\n\nPopulation biomass\n\n\nTotal biomass\n\n\nFood web diversity\n\n\nSaving the simulations\n\n\n\n\n\n\n\n\n\n\nReference\n\n\nUser functions\n\n\nSimulations\n\n\nMeasures on output\n\n\nNetwork utilities\n\n\n\n\n\n\nInternal functions\n\n\nPreparation of parameters\n\n\nInternal simulation functions\n\n\nNumerical integration\n\n\nInternal checks\n\n\nOther functions\n\n\n\n\n\n\n\n\n\n\nChangelog\n\n\n0.0.2\n\n\n0.0.1",
            "title": "Home"
        },
        {
            "location": "/#befwm-documentation",
            "text": "User guide  Generating random networks  Niche model    Overview of the simulation  Create model parameters  Simulation    Measures on output  Population variability  Population biomass  Total biomass  Food web diversity  Saving the simulations      Reference  User functions  Simulations  Measures on output  Network utilities    Internal functions  Preparation of parameters  Internal simulation functions  Numerical integration  Internal checks  Other functions      Changelog  0.0.2  0.0.1",
            "title": "befwm documentation"
        },
        {
            "location": "/user/userguide/",
            "text": "User guide\n\n\nIf you have followed the instructions for installation in the first pages of this manual, from within julia, \nbefwm\n can be imported as usual:\n\n\nusing befwm\n\n\n\n\nIn this part of the manual, we will walk through the overall design and usage of \nbefwm\n.\n\n\nSpecifically, we will cover how to run simulations, generate random networks, then deal with the output of the simulations.",
            "title": "Introduction"
        },
        {
            "location": "/user/userguide/#user-guide",
            "text": "If you have followed the instructions for installation in the first pages of this manual, from within julia,  befwm  can be imported as usual:  using befwm  In this part of the manual, we will walk through the overall design and usage of  befwm .  Specifically, we will cover how to run simulations, generate random networks, then deal with the output of the simulations.",
            "title": "User guide"
        },
        {
            "location": "/user/user_random/",
            "text": "Generating random networks\n\n\nThe \nbefwm\n allows the generation of random networks. It is, of course, possible to supply your own. The networks should be presented as matrices of 0 and 1. Internally, \nbefwm\n will check that there are as many rows as there are columns.\n\n\n\n\nNiche model\n\n\nFollowing Williams & Martinez {{ \"williams-martinez\" | cite }}, we have implemented the \nniche\n model of food webs. This model represents allometric relationships between preys and predators well {{ \"gravel\" | cite }}, and is therefore well suited to generate random networks for \nbefwm\n.\n\n\nRandom niche model networks can be generated using \nnichemodel\n, which takes two arguments: the number of species \nS\n, and the number of interactions \nL\n:\n\n\nnichemodel(10, 12)\nnichemodel(10, 15)\nnichemodel(10, 50)",
            "title": "Generating networks"
        },
        {
            "location": "/user/user_random/#generating-random-networks",
            "text": "The  befwm  allows the generation of random networks. It is, of course, possible to supply your own. The networks should be presented as matrices of 0 and 1. Internally,  befwm  will check that there are as many rows as there are columns.",
            "title": "Generating random networks"
        },
        {
            "location": "/user/user_random/#niche-model",
            "text": "Following Williams & Martinez {{ \"williams-martinez\" | cite }}, we have implemented the  niche  model of food webs. This model represents allometric relationships between preys and predators well {{ \"gravel\" | cite }}, and is therefore well suited to generate random networks for  befwm .  Random niche model networks can be generated using  nichemodel , which takes two arguments: the number of species  S , and the number of interactions  L :  nichemodel(10, 12)\nnichemodel(10, 15)\nnichemodel(10, 50)",
            "title": "Niche model"
        },
        {
            "location": "/user/user_general/",
            "text": "Overview of the simulation\n\n\nRunning a simulation has three steps. First, setting up a series of initial parameters. Second, generating the body sizes, metabolic rates, \netc.\n. Finally, starting the simulation itself.\n\n\nStarting from a network \nA\n, this is as simple as\n\n\nA = [0 1 0 0; 0 0 1 1; 0 0 0 0; 0 0 0 0]\np = model_parameters(A)\ninitial_biomass = rand(size(A, 1))\nd = simulate(p, initial_biomass, start=0, stop=100, steps=10000)\n\n\n\n\nWe will see in the next sections what each of these steps do.\n\n\nAll networks are expected to be square, with only \n0\n or \n1\n, and have predators in rows and preys in columns. In addition, it is expected that \nat least\n one species is a primary producer (\ni.e.\n at least one of the rows in the matrix has no interaction). This is checked internally by the different functions.\n\n\n\n\nCreate model parameters\n\n\nFirst, create or import an interaction matrix, with predators in rows and preys in columns:\n\n\n#=\nPredators are in rows, so this corresponds to a \"diamond\" food web: 1 eats\n2 and 3, and 2 and 3 eat 4. 1 is a top predator, 2 and 3 are intermediate\nconsumers, and 4 is a primary producer.\n=#\nA = [0 1 1 0; 0 0 0 1; 0 0 0 1; 0 0 0 0]\n\n# We start with random biomasses in [0;1]\ninitial_biomasses = rand(size(A, 1))\n\n\n\n\nOnce done, get the initial parameters, and if needed change some of their values:\n\n\np = model_parameters(A, Z=2.0)\n\n\n\n\nTo see what the initial parameters values are, either look at the \np\n object, or (better) at the help of \nmodel_parameters\n, with\n\n\n?model_parameters\n\n\n\n\n\n\nSimulation\n\n\nTo start with random biomasses:\n\n\nprintln(simulate(p, initial_biomasses))",
            "title": "Simulations"
        },
        {
            "location": "/user/user_general/#overview-of-the-simulation",
            "text": "Running a simulation has three steps. First, setting up a series of initial parameters. Second, generating the body sizes, metabolic rates,  etc. . Finally, starting the simulation itself.  Starting from a network  A , this is as simple as  A = [0 1 0 0; 0 0 1 1; 0 0 0 0; 0 0 0 0]\np = model_parameters(A)\ninitial_biomass = rand(size(A, 1))\nd = simulate(p, initial_biomass, start=0, stop=100, steps=10000)  We will see in the next sections what each of these steps do.  All networks are expected to be square, with only  0  or  1 , and have predators in rows and preys in columns. In addition, it is expected that  at least  one species is a primary producer ( i.e.  at least one of the rows in the matrix has no interaction). This is checked internally by the different functions.",
            "title": "Overview of the simulation"
        },
        {
            "location": "/user/user_general/#create-model-parameters",
            "text": "First, create or import an interaction matrix, with predators in rows and preys in columns:  #=\nPredators are in rows, so this corresponds to a \"diamond\" food web: 1 eats\n2 and 3, and 2 and 3 eat 4. 1 is a top predator, 2 and 3 are intermediate\nconsumers, and 4 is a primary producer.\n=#\nA = [0 1 1 0; 0 0 0 1; 0 0 0 1; 0 0 0 0]\n\n# We start with random biomasses in [0;1]\ninitial_biomasses = rand(size(A, 1))  Once done, get the initial parameters, and if needed change some of their values:  p = model_parameters(A, Z=2.0)  To see what the initial parameters values are, either look at the  p  object, or (better) at the help of  model_parameters , with  ?model_parameters",
            "title": "Create model parameters"
        },
        {
            "location": "/user/user_general/#simulation",
            "text": "To start with random biomasses:  println(simulate(p, initial_biomasses))",
            "title": "Simulation"
        },
        {
            "location": "/user/user_measures/",
            "text": "Measures on output\n\n\nThese functions let you work with the output of the simulations (\ni.e.\n the object returned by \nsimulate\n).\n\n\n\n\nPopulation variability\n\n\nIn the original paper {{ \"brose\" | cite }}, population variability is defined as the average of the negative coefficients of variations of biomasses of persisting species. This can be measured using the \npopulation_stability\n function. There are two arguments you can act on: \nlast\n (the number of timesteps before the end on which the stability should be measured), and \nthreshold\n (the biomass under which populations are considered extinct for the purpose of this measure).\n\n\nThis measure is \nextremely\n sensitive to both of these parameters, especially when the system does not reach a stable equilibrium. We found that a way to give much more stable results is to consider \nall\n species, even those with very small biomasses. This can be done by setting a \nnegative\n threshold. Usually, at least 1000 timesteps are required to get a stable estimate of stability.\n\n\nNote that in the original paper, what is presented is actually this measure, multiplied by 100, which is the \nrelative standard error\n, and not the coefficient of variation. Note also that, so as to correct for the fact that the number of timesteps varies, we use the corrected estimator of the coefficient of variation.\n\n\n\n\nPopulation biomass\n\n\nThe \npopulation_biomass\n function returns the average biomass over \nlast\n timesteps for \nevery\n population in the network.\n\n\n\n\nTotal biomass\n\n\nThe \ntotal_biomass\n function returns the total biomass over \nlast\n timesteps for the entire network.\n\n\n\n\nFood web diversity\n\n\nThe \nfoodweb_diversity\n is the Shannon entropy measure, corrected for the number of population (\ni.e.\n, divided by the natural log of the number of populations). Values of 1 indicate high evenness, and values close to 0 indicate extreme un-evenness. In the original paper, diversity is measured as the number of species with a biomass above a given threshold. Given that this threshold has to be set in an arbitrary way, and does not account for the fact that changing several parameters also changes the distribution of biomasses, we have not retained this measurement of diversity.\n\n\n\n\nSaving the simulations\n\n\nThe object returned by \nsimulate\n can be saved using the \nbefwm.save\n function. This function is \nnot\n exported, so it must be called with the \nbefwm.\n prefix. By default, this function will generate a unique identifier for every simulation. It is generally considered good practice to save the simulation outputs, and process them later, rather than working on the objects without saving them. In case one wants to return to the simulations at a later time, saving the objects allows to forgo re-running the simulations, and can therefore save significant amounts of time.",
            "title": "Measures on output"
        },
        {
            "location": "/user/user_measures/#measures-on-output",
            "text": "These functions let you work with the output of the simulations ( i.e.  the object returned by  simulate ).",
            "title": "Measures on output"
        },
        {
            "location": "/user/user_measures/#population-variability",
            "text": "In the original paper {{ \"brose\" | cite }}, population variability is defined as the average of the negative coefficients of variations of biomasses of persisting species. This can be measured using the  population_stability  function. There are two arguments you can act on:  last  (the number of timesteps before the end on which the stability should be measured), and  threshold  (the biomass under which populations are considered extinct for the purpose of this measure).  This measure is  extremely  sensitive to both of these parameters, especially when the system does not reach a stable equilibrium. We found that a way to give much more stable results is to consider  all  species, even those with very small biomasses. This can be done by setting a  negative  threshold. Usually, at least 1000 timesteps are required to get a stable estimate of stability.  Note that in the original paper, what is presented is actually this measure, multiplied by 100, which is the  relative standard error , and not the coefficient of variation. Note also that, so as to correct for the fact that the number of timesteps varies, we use the corrected estimator of the coefficient of variation.",
            "title": "Population variability"
        },
        {
            "location": "/user/user_measures/#population-biomass",
            "text": "The  population_biomass  function returns the average biomass over  last  timesteps for  every  population in the network.",
            "title": "Population biomass"
        },
        {
            "location": "/user/user_measures/#total-biomass",
            "text": "The  total_biomass  function returns the total biomass over  last  timesteps for the entire network.",
            "title": "Total biomass"
        },
        {
            "location": "/user/user_measures/#food-web-diversity",
            "text": "The  foodweb_diversity  is the Shannon entropy measure, corrected for the number of population ( i.e. , divided by the natural log of the number of populations). Values of 1 indicate high evenness, and values close to 0 indicate extreme un-evenness. In the original paper, diversity is measured as the number of species with a biomass above a given threshold. Given that this threshold has to be set in an arbitrary way, and does not account for the fact that changing several parameters also changes the distribution of biomasses, we have not retained this measurement of diversity.",
            "title": "Food web diversity"
        },
        {
            "location": "/user/user_measures/#saving-the-simulations",
            "text": "The object returned by  simulate  can be saved using the  befwm.save  function. This function is  not  exported, so it must be called with the  befwm.  prefix. By default, this function will generate a unique identifier for every simulation. It is generally considered good practice to save the simulation outputs, and process them later, rather than working on the objects without saving them. In case one wants to return to the simulations at a later time, saving the objects allows to forgo re-running the simulations, and can therefore save significant amounts of time.",
            "title": "Saving the simulations"
        },
        {
            "location": "/api/",
            "text": "Reference\n\n\n\n\nUser functions\n\n\nThis page lists the functions that are exported by \nbefwm\n, in the other where you are likely to use them.\n\n\n\n\nSimulations\n\n\n#\n\n\nbefwm.model_parameters\n \u2014 \nFunction\n.\n\n\nCreate default parameters\n\n\nThis function creates model parameters, based on a food web matrix. Specifically, the default values are:\n\n\n Parameter | Default Value |                                                                             Meaning\n\n\n\n-------------: | ------------: | ----------------------------------------------------------------------------------:\n             K |           1.0 |                                                      carrying capacity of producers\n             Z |           1.0 |                                                   consumer-resource body mass ratio\n             r |           1.0 |                                                            growth rate of producers\na_invertebrate |         0.314 |                                      allometric constant for invertebrate consumers\n   a_producers |           1.0 |                                                    allometric constant of producers\n  a_vertebrate |          0.88 |                                        allometric constant for vertebrate consumers\n             c |             0 |                                                quantifies the predator interference\n             h |             1 |                                                                    Hill coefficient\n   e_carnivore |          0.85 |                                               assimilation efficiency of carnivores\n   e_herbivore |          0.45 |                                               assimilation efficiency of herbivores\n   m_producers |             1 |                                                              body-mass of producers\ny_invertebrate |             8 | maximum consumption rate of invertebrate predators relative to their metabolic rate\n  y_vertebrate |             4 |   maximum consumption rate of vertebrate predators relative to their metabolic rate\n             \u0393 |           0.5 |                                                             half-saturation density\n\n\nAll of these values are passed as optional keyword arguments to the function.\n\n\nAlternatively, every parameter can be used as a \nkeyword\n argument when calling the function. For example\n\n\nA = [0 1 1; 0 0 0; 0 0 0]\np = model_parameters(A, Z=100.0)\n\n\n\n\nThe final keyword is \nvertebrates\n, which is an array of \ntrue\n or \nfalse\n for every species in the matrix. By default, all species are invertebrates.\n\n\n#\n\n\nbefwm.simulate\n \u2014 \nFunction\n.\n\n\nMain simulation loop\n\n\nThis function takes two mandatory arguments:\n\n\n\n\np\n is a \nDict\n as returned by \nmake_parameters\n\n\nbiomass\n is a \nArray{Float64, 1}\n with the initial biomasses of every species\n\n\n\n\nInternally, the function will check that the length of \nbiomass\n matches with the size of the network.\n\n\nIn addition, the function takes three optional arguments:\n\n\n\n\nstart\n (defaults to 0), the initial time\n\n\nstop\n (defaults to 500), the final time\n\n\nsteps\n (defaults to 5000), the number of internal steps\n\n\nuse\n (defaults to \n:ode45\n), the integration method\n\n\n\n\nNote that the value of \nsteps\n is the number of intermediate steps when moving from \nt\n to \nt+1\n. The total number of steps is therefore on the order of (stop - start) * steps.\n\n\nBecause this results in very large simulations, the function will return results with a timestep equal to unity.\n\n\nThe integration method is, by default, \n:ode45\n, and can be changed to one of \n:ode23\n, \n:ode45\n, \n:ode78\n, or \n:ode23s\n.\n\n\nThe \nsimulate\n function returns a \nDict{Symbol, Any}\n, with three top-level keys:\n\n\n\n\n:p\n, the parameters that were given as input\n\n\n:t\n, the timesteps\n\n\n:B\n, an \nArray{Float64, 2}\n with the biomasses\n\n\n\n\nThe array of biomasses has one row for each timestep, and one column for each species.\n\n\nIf the difference between stop and start is more than an arbitrary threshold (currently 500 timesteps), the simulations will be run in chunks of 500 timesteps each. This is because the amount of memory needed to store the dynamics scales very badly. To avoid \nOutOfMemory()\n errors, running the simulation by parts is sufficient.\n\n\n\n\nMeasures on output\n\n\nAll of these functions work on the output of \nsimulate\n\n\n#\n\n\nbefwm.population_stability\n \u2014 \nFunction\n.\n\n\nPopulation stability\n\n\nTakes a matrix with populations in columns, timesteps in rows. This is usually the element \n:B\n of the simulation output. Population stability is measured as the mean of the negative coefficient of variations of all species with an abundance higher than \nthreshold\n. By default, the stability is measure over the last \nlast=1000\n timesteps.\n\n\n#\n\n\nbefwm.population_biomass\n \u2014 \nFunction\n.\n\n\nPer species biomass\n\n\nReturns the average biomass of all species, over the last \nlast\n timesteps.\n\n\n#\n\n\nbefwm.total_biomass\n \u2014 \nFunction\n.\n\n\nTotal biomass\n\n\nReturns the sum of biomass, average over the last \nlast\n timesteps.\n\n\n#\n\n\nbefwm.foodweb_diversity\n \u2014 \nFunction\n.\n\n\nFood web diversity\n\n\nBased on the average of Shannon's entropy over the last \nlast\n timesteps.\n\n\n#\n\n\nbefwm.save\n \u2014 \nFunction\n.\n\n\nSave the output of a simulation\n\n\nTakes a simulation output as a mandatory argument. The two keyword arguments are \nas\n (can be \n:json\n or \n:jld\n), defining the file format, and \nfilename\n (without an extension, defaults to \nNaN\n). If \n:jld\n is used, the variable is named \nbefwm_simul\n unless a \nvarname\n is given.\n\n\nCalled with the defaults, this function will write \nbefwm_xxxxxxxx.json\n with the current simulation output, where \nxxxxxxxx\n is a hash of the \np\n output (ensuring that all output files are unique).\n\n\nThis function is \nnot\n exported, so it must be called with \nbefwm.save\n.\n\n\n\n\nNetwork utilities\n\n\n#\n\n\nbefwm.trophic_rank\n \u2014 \nFunction\n.\n\n\nTrophic rank\n\n\nBased on the average distance of preys to primary producers. Specifically, the rank is defined as the average of the distance of preys to primary producers (recursively). Primary producers always have a trophic rank of 1.\n\n\n#\n\n\nbefwm.nichemodel\n \u2014 \nFunction\n.\n\n\nNiche model of food webs\n\n\nTakes a number of species \nS\n and a connectance \nC\n, and returns a food web with predators in rows, and preys in columns. Note that the connectance is first transformed into an integer number of interactions.\n\n\nNiche model of food webs\n\n\nTakes a number of species \nS\n and a number of interactions \nL\n, and returns a food web with predators in rows, and preys in columns.\n\n\n\n\nInternal functions\n\n\nThese functions are unlikely to bee needed in a common workflow, but are presented here in case you need to manipulate the internals of \nbefwm\n.\n\n\n\n\nPreparation of parameters\n\n\n#\n\n\nbefwm.make_initial_parameters\n \u2014 \nFunction\n.\n\n\nMake initial parameters\n\n\nUsed internally by \nmodel_parameters\n.\n\n\n#\n\n\nbefwm.make_parameters\n \u2014 \nFunction\n.\n\n\nMake the complete set of parameters\n\n\nThis function will add simulation parameters, based on the output of \nmake_initial_parameters\n. Used internally by \nmodel_parameters\n.\n\n\n\n\nInternal simulation functions\n\n\n#\n\n\nbefwm.dBdt\n \u2014 \nFunction\n.\n\n\nDerivatives\n\n\nThis function is the one wrapped by the various integration routines. Based on a timepoint \nt\n, an array of biomasses \nbiomass\n, an equally sized array of derivatives \nderivative\n, and a series of simulation parameters \np\n, it will return \ndB/dt\n for every species.\n\n\nNote that at the end of the function, we perform different checks to ensure that nothing wacky happens during subsequent integration steps. Specifically, if B+dB/dt < \u03f5(0.0), we set dBdt to -B. \u03f5(0.0) is the next value above 0.0 that your system can represent.\n\n\n#\n\n\nbefwm.inner_simulation_loop!\n \u2014 \nFunction\n.\n\n\nInner simulation loop\n\n\nThis function is called internally by \nsimulate\n, and should not be called by the user.\n\n\nNote that \noutput\n is a pre-allocated array in which the simulation result will be written, and \ni\n is the origin of the simulation.\n\n\n\n\nNumerical integration\n\n\n#\n\n\nbefwm.wrap_ode\n \u2014 \nFunction\n.\n\n\nWrapper for ode functions\n\n\nThese functions will let \nODE\n do its job, then return the results in way we can handle.\n\n\n#\n\n\nbefwm.wrap_ode45\n \u2014 \nFunction\n.\n\n\nWrapper for ode45\n\n\nSee \nwrap_ode\n.\n\n\n#\n\n\nbefwm.wrap_ode78\n \u2014 \nFunction\n.\n\n\nWrapper for ode78\n\n\nSee \nwrap_ode\n.\n\n\n#\n\n\nbefwm.wrap_ode23\n \u2014 \nFunction\n.\n\n\nWrapper for ode23\n\n\nSee \nwrap_ode\n.\n\n\n#\n\n\nbefwm.wrap_ode23s\n \u2014 \nFunction\n.\n\n\nWrapper for ode23s\n\n\nSee \nwrap_ode\n.\n\n\n\n\nInternal checks\n\n\n#\n\n\nbefwm.check_parameters\n \u2014 \nFunction\n.\n\n\nAre the simulation parameters present?\n\n\nThis function will make sure that all the required parameters are here, and that the arrays and matrices have matching dimensions.\n\n\n#\n\n\nbefwm.check_food_web\n \u2014 \nFunction\n.\n\n\nIs the matrix correctly formatted?\n\n\nA \ncorrect\n matrix has only 0 and 1, two dimensions, and is square.\n\n\nThis function returns nothing, but raises an \nAssertionError\n if one of the conditions is not met.\n\n\n\n\nOther functions\n\n\n#\n\n\nbefwm.shannon\n \u2014 \nFunction\n.\n\n\nShannon's entropy\n\n\nCorrected for the number of species, removes negative and null values, return \nNaN\n in case of problem.\n\n\n#\n\n\nbefwm.coefficient_of_variation\n \u2014 \nFunction\n.\n\n\nCoefficient of variation\n\n\nCorrected for the sample size.\n\n\n#\n\n\nbefwm.distance_to_producer\n \u2014 \nFunction\n.\n\n\nDistance to a primary producer\n\n\nThis function measures, for every species, its shortest path to a primary producer using matrix exponentiation. A primary producer has a value of 1, a primary consumer a value of 2, and so forth.",
            "title": "Reference"
        },
        {
            "location": "/api/#reference",
            "text": "",
            "title": "Reference"
        },
        {
            "location": "/api/#user-functions",
            "text": "This page lists the functions that are exported by  befwm , in the other where you are likely to use them.",
            "title": "User functions"
        },
        {
            "location": "/api/#simulations",
            "text": "#  befwm.model_parameters  \u2014  Function .  Create default parameters  This function creates model parameters, based on a food web matrix. Specifically, the default values are:   Parameter | Default Value |                                                                             Meaning  -------------: | ------------: | ----------------------------------------------------------------------------------:\n             K |           1.0 |                                                      carrying capacity of producers\n             Z |           1.0 |                                                   consumer-resource body mass ratio\n             r |           1.0 |                                                            growth rate of producers\na_invertebrate |         0.314 |                                      allometric constant for invertebrate consumers\n   a_producers |           1.0 |                                                    allometric constant of producers\n  a_vertebrate |          0.88 |                                        allometric constant for vertebrate consumers\n             c |             0 |                                                quantifies the predator interference\n             h |             1 |                                                                    Hill coefficient\n   e_carnivore |          0.85 |                                               assimilation efficiency of carnivores\n   e_herbivore |          0.45 |                                               assimilation efficiency of herbivores\n   m_producers |             1 |                                                              body-mass of producers\ny_invertebrate |             8 | maximum consumption rate of invertebrate predators relative to their metabolic rate\n  y_vertebrate |             4 |   maximum consumption rate of vertebrate predators relative to their metabolic rate\n             \u0393 |           0.5 |                                                             half-saturation density  All of these values are passed as optional keyword arguments to the function.  Alternatively, every parameter can be used as a  keyword  argument when calling the function. For example  A = [0 1 1; 0 0 0; 0 0 0]\np = model_parameters(A, Z=100.0)  The final keyword is  vertebrates , which is an array of  true  or  false  for every species in the matrix. By default, all species are invertebrates.  #  befwm.simulate  \u2014  Function .  Main simulation loop  This function takes two mandatory arguments:   p  is a  Dict  as returned by  make_parameters  biomass  is a  Array{Float64, 1}  with the initial biomasses of every species   Internally, the function will check that the length of  biomass  matches with the size of the network.  In addition, the function takes three optional arguments:   start  (defaults to 0), the initial time  stop  (defaults to 500), the final time  steps  (defaults to 5000), the number of internal steps  use  (defaults to  :ode45 ), the integration method   Note that the value of  steps  is the number of intermediate steps when moving from  t  to  t+1 . The total number of steps is therefore on the order of (stop - start) * steps.  Because this results in very large simulations, the function will return results with a timestep equal to unity.  The integration method is, by default,  :ode45 , and can be changed to one of  :ode23 ,  :ode45 ,  :ode78 , or  :ode23s .  The  simulate  function returns a  Dict{Symbol, Any} , with three top-level keys:   :p , the parameters that were given as input  :t , the timesteps  :B , an  Array{Float64, 2}  with the biomasses   The array of biomasses has one row for each timestep, and one column for each species.  If the difference between stop and start is more than an arbitrary threshold (currently 500 timesteps), the simulations will be run in chunks of 500 timesteps each. This is because the amount of memory needed to store the dynamics scales very badly. To avoid  OutOfMemory()  errors, running the simulation by parts is sufficient.",
            "title": "Simulations"
        },
        {
            "location": "/api/#measures-on-output",
            "text": "All of these functions work on the output of  simulate  #  befwm.population_stability  \u2014  Function .  Population stability  Takes a matrix with populations in columns, timesteps in rows. This is usually the element  :B  of the simulation output. Population stability is measured as the mean of the negative coefficient of variations of all species with an abundance higher than  threshold . By default, the stability is measure over the last  last=1000  timesteps.  #  befwm.population_biomass  \u2014  Function .  Per species biomass  Returns the average biomass of all species, over the last  last  timesteps.  #  befwm.total_biomass  \u2014  Function .  Total biomass  Returns the sum of biomass, average over the last  last  timesteps.  #  befwm.foodweb_diversity  \u2014  Function .  Food web diversity  Based on the average of Shannon's entropy over the last  last  timesteps.  #  befwm.save  \u2014  Function .  Save the output of a simulation  Takes a simulation output as a mandatory argument. The two keyword arguments are  as  (can be  :json  or  :jld ), defining the file format, and  filename  (without an extension, defaults to  NaN ). If  :jld  is used, the variable is named  befwm_simul  unless a  varname  is given.  Called with the defaults, this function will write  befwm_xxxxxxxx.json  with the current simulation output, where  xxxxxxxx  is a hash of the  p  output (ensuring that all output files are unique).  This function is  not  exported, so it must be called with  befwm.save .",
            "title": "Measures on output"
        },
        {
            "location": "/api/#network-utilities",
            "text": "#  befwm.trophic_rank  \u2014  Function .  Trophic rank  Based on the average distance of preys to primary producers. Specifically, the rank is defined as the average of the distance of preys to primary producers (recursively). Primary producers always have a trophic rank of 1.  #  befwm.nichemodel  \u2014  Function .  Niche model of food webs  Takes a number of species  S  and a connectance  C , and returns a food web with predators in rows, and preys in columns. Note that the connectance is first transformed into an integer number of interactions.  Niche model of food webs  Takes a number of species  S  and a number of interactions  L , and returns a food web with predators in rows, and preys in columns.",
            "title": "Network utilities"
        },
        {
            "location": "/api/#internal-functions",
            "text": "These functions are unlikely to bee needed in a common workflow, but are presented here in case you need to manipulate the internals of  befwm .",
            "title": "Internal functions"
        },
        {
            "location": "/api/#preparation-of-parameters",
            "text": "#  befwm.make_initial_parameters  \u2014  Function .  Make initial parameters  Used internally by  model_parameters .  #  befwm.make_parameters  \u2014  Function .  Make the complete set of parameters  This function will add simulation parameters, based on the output of  make_initial_parameters . Used internally by  model_parameters .",
            "title": "Preparation of parameters"
        },
        {
            "location": "/api/#internal-simulation-functions",
            "text": "#  befwm.dBdt  \u2014  Function .  Derivatives  This function is the one wrapped by the various integration routines. Based on a timepoint  t , an array of biomasses  biomass , an equally sized array of derivatives  derivative , and a series of simulation parameters  p , it will return  dB/dt  for every species.  Note that at the end of the function, we perform different checks to ensure that nothing wacky happens during subsequent integration steps. Specifically, if B+dB/dt < \u03f5(0.0), we set dBdt to -B. \u03f5(0.0) is the next value above 0.0 that your system can represent.  #  befwm.inner_simulation_loop!  \u2014  Function .  Inner simulation loop  This function is called internally by  simulate , and should not be called by the user.  Note that  output  is a pre-allocated array in which the simulation result will be written, and  i  is the origin of the simulation.",
            "title": "Internal simulation functions"
        },
        {
            "location": "/api/#numerical-integration",
            "text": "#  befwm.wrap_ode  \u2014  Function .  Wrapper for ode functions  These functions will let  ODE  do its job, then return the results in way we can handle.  #  befwm.wrap_ode45  \u2014  Function .  Wrapper for ode45  See  wrap_ode .  #  befwm.wrap_ode78  \u2014  Function .  Wrapper for ode78  See  wrap_ode .  #  befwm.wrap_ode23  \u2014  Function .  Wrapper for ode23  See  wrap_ode .  #  befwm.wrap_ode23s  \u2014  Function .  Wrapper for ode23s  See  wrap_ode .",
            "title": "Numerical integration"
        },
        {
            "location": "/api/#internal-checks",
            "text": "#  befwm.check_parameters  \u2014  Function .  Are the simulation parameters present?  This function will make sure that all the required parameters are here, and that the arrays and matrices have matching dimensions.  #  befwm.check_food_web  \u2014  Function .  Is the matrix correctly formatted?  A  correct  matrix has only 0 and 1, two dimensions, and is square.  This function returns nothing, but raises an  AssertionError  if one of the conditions is not met.",
            "title": "Internal checks"
        },
        {
            "location": "/api/#other-functions",
            "text": "#  befwm.shannon  \u2014  Function .  Shannon's entropy  Corrected for the number of species, removes negative and null values, return  NaN  in case of problem.  #  befwm.coefficient_of_variation  \u2014  Function .  Coefficient of variation  Corrected for the sample size.  #  befwm.distance_to_producer  \u2014  Function .  Distance to a primary producer  This function measures, for every species, its shortest path to a primary producer using matrix exponentiation. A primary producer has a value of 1, a primary consumer a value of 2, and so forth.",
            "title": "Other functions"
        },
        {
            "location": "/LICENSE/",
            "text": "Copyright (c) 2016 The Poisot Lab \ntim@poisotlab.io\n    Author: Poisot, Timoth\u00e9e \ntim@poisotlab.io\n; Delmas, Eva \neva.delmas@umontreal.ca\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
            "title": "License"
        },
        {
            "location": "/CHANGELOG/",
            "text": "Changelog\n\n\n\n\n0.0.2\n\n\n\n\nsingle function for model parameters (\nmodel_parameters\n)\n\n\nremoved \nSundials\n (memory leak) and \nEuler\n (it's 2016) from the code\n\n\n\n\n\n\n0.0.1\n\n\n\n\nfirst release",
            "title": "Release notes"
        },
        {
            "location": "/CHANGELOG/#changelog",
            "text": "",
            "title": "Changelog"
        },
        {
            "location": "/CHANGELOG/#002",
            "text": "single function for model parameters ( model_parameters )  removed  Sundials  (memory leak) and  Euler  (it's 2016) from the code",
            "title": "0.0.2"
        },
        {
            "location": "/CHANGELOG/#001",
            "text": "first release",
            "title": "0.0.1"
        }
    ]
}